Summer of SQL Week 7 - Preppin Data 2023 Weeks 9-12

// 2023: Week 9 - Customer Bank Statements
For the Transaction Path table:
Make sure field naming convention matches the other tables
i.e. instead of Account_From it should be Account From
Filter out the cancelled transactions
Split the flow into incoming and outgoing transactions 
Bring the data together with the Balance as of 31st Jan 
Work out the order that transactions occur for each account
Hint: where multiple transactions happen on the same day, assume the highest value transactions happen first
Use a running sum to calculate the Balance for each account on each day (hint)
The Transaction Value should be null for 31st Jan, as this is the starting balance

with account_to_table as (
select account_to as account_num,
transaction_date,
value,
balance
from pd2023_wk07_transaction_path as tp
join PD2023_WK07_TRANSACTION_DETAIL as td on tp.transaction_id = td.transaction_id
join PD2023_WK07_ACCOUNT_INFORMATION as ai on tp.account_to = ai.account_number
where cancelled_ <> 'Y'
and balance_date = '2023-01-31'


union all 

select account_to as account_num,
transaction_date,
value * (-1) as value,
balance
from pd2023_wk07_transaction_path as tp
join PD2023_WK07_TRANSACTION_DETAIL as td on tp.transaction_id = td.transaction_id
join PD2023_WK07_ACCOUNT_INFORMATION as ai on tp.account_from = ai.account_number
where cancelled_ <> 'Y'
and balance_date = '2023-01-31'

union all

select account_number as account_num,
balance_date as transaction_date,
NULL as value,
balance
from PD2023_WK07_ACCOUNT_INFORMATION

)

// 2023: Week 10 Preppin Data
Aggregate the data so we have a single balance for each day already in the dataset, for each account
Scaffold the data so each account has a row between 31st Jan and 14th Feb (hint)
Make sure new rows have a null in the Transaction Value field
Create a parameter so a particular date can be selected
Filter to just this date


with week10input as (
with account_to_table as (
select account_to as account_num,
transaction_date,
value,
balance
from pd2023_wk07_transaction_path as tp
join PD2023_WK07_TRANSACTION_DETAIL as td on tp.transaction_id = td.transaction_id
join PD2023_WK07_ACCOUNT_INFORMATION as ai on tp.account_to = ai.account_number
where cancelled_ <> 'Y'
and balance_date = '2023-01-31'


union all 

select account_to as account_num,
transaction_date,
value * (-1) as value,
balance
from pd2023_wk07_transaction_path as tp
join PD2023_WK07_TRANSACTION_DETAIL as td on tp.transaction_id = td.transaction_id
join PD2023_WK07_ACCOUNT_INFORMATION as ai on tp.account_from = ai.account_number
where cancelled_ <> 'Y'
and balance_date = '2023-01-31'

union all

select account_number as account_num,
balance_date as transaction_date,
NULL as value,
balance
from PD2023_WK07_ACCOUNT_INFORMATION

)

select account_num,
transaction_date,
value,
SUM(COALESCE(value,0)) OVER(PARTITION BY account_num ORDER BY transaction_date, value DESC) + balance as balance
from account_to_table
order by account_num, transaction_date, value DESC
)
, DAILY_TRANSACTIONS as (
select account_num,
transaction_date,
sum(balance) as balance
from week10input
group by account_num, transaction_date
)
,single_balance as (
select *, ROW_NUMBER() OVER(PARTITION by account_num, transaction_date order by value ASC) as rn
from week10input
)
, daily_balance as (
select sb.account_num,
sb.transaction_date,
value,
dt.balance
from single_balance as sb
join daily_transactions as dt on dt.account_num = sb.account_num and dt.transaction_date = sb. transaction_date
where rn = 1
)
, account_numbers AS (
SELECT DISTINCT 
account_num
FROM daily_balance
)
,numbers AS (
SELECT '2023-01-31'::date as d,
account_num 
FROM account_numbers

union all

select dateadd('day' ,1,d),
account_num
from numbers
where d < '2023-02-14'::date 
)
,
daily_table as (
select
n.account_num,
n.d as transaction_date,
db.value,
db.balance as balance2,
sb.transaction_date as transaction_date2,
sb.balance,
datediff('day' ,sb.transaction_date,n.d) as date_diff,
ROW_NUMBER() OVER(PARTITION BY n.account_num,n.d ORDER BY datediff('day',sb.transaction_date,n.d)) as rn
from numbers as n
left join daily_balance as db on n.account_num = db.account_num and n.d = db.transaction_date
join single_balance as sb on sb.account_num = n.account_num and sb.transaction_date <= n.d
order by n.account_num, n.d
)

select account_num,
transaction_date,
value,
balance
from daily_table
where rn = 1


select account_num,
transaction_date,
value,
SUM(COALESCE(value,0)) OVER(PARTITION BY account_num ORDER BY transaction_date, value DESC) + balance as balance
from account_to_table
order by account_num, transaction_date, value DESC;

// Week 11 Preppin Data


select customer,
branch,
MIN(ROUND(ST_DISTANCE(
    ST_POINT(address_long, address_lat),
    ST_POINT(branch_long, branch_lat)),2
    )) as distance,
    ROW_NUMBER() OVER(PARTITION BY customer ORDER BY distance ASC) as customer_priority
from PD2023_WK11_DSB_CUSTOMER_LOCATIONS as C
join PD2023_WK11_DSB_BRANCHES as B 
group by customer, branch;


// Week 12 Preppin Data



with CTE as (
select *,
NULLIF(YEAR, '') AS YEAR2,
count(YEAR2) over (order by ROW_NUM) as _grp
from PD2023_WK12_UK_BANK_HOLIDAYS
), CTE2 as (
select DATE, BANK_HOLIDAY, _grp,
 first_value(YEAR2) over (partition by _grp order by ROW_NUM) as filled_YEAR,
 concat(DATE, '-',filled_year) as full_date 
 from CTE
 ),
 BH as (
 select bank_holiday, 
 TO_DATE(FULL_DATE, 'DD-Mon-YYYY') AS bh_date
 from CTE2 
 where DATE <> ''
)
, UK as (
select new_customers,
TO_DATE(DATE, 'DD/MM/YYYY') AS new_date
from PD2023_WK12_NEW_CUSTOMERS
), 
UKBH as (
select *,
DAYNAME(NEW_DATE) AS day_of_week,
case
when bank_holiday is null AND  
 (DAYNAME(NEW_DATE) NOT IN ('Sat', 'Sun'))
    THEN 1
    ELSE 0
END AS Reporting_Day
from UK
left Join BH on uk.new_date = bh.bh_date
) , no_reporting as (
select distinct
NEW_DATE as non_report_date
from UKBH
where reporting_day = 0
)
, reporting_lookup as (
select non_report_date,
min(NEW_DATE) as next_report_date
from UKBH 
inner join no_reporting as nr on nr.non_report_date < ukbh.new_date
where reporting_day = 1
group by non_report_date
)
, uk_report as (
select coalesce(next_report_date,new_date) as date,
monthname(coalesce(next_report_date,new_date)) || '-' || YEAR(coalesce(next_report_date,new_date)) as month,
sum(new_customers) as new_customers
from UKBH 
left join reporting_lookup as rl on rl.non_report_date = UKBH.new_date
group by 1,2
)
, UK_last_day as (
select month,
max(date) as last_date
from uk_report
group by month
)
, uk_report_adj as (
select case
        when last_date is null then monthname(date) || '-' || year(date)
        else monthname(DATEADD('month',1,date)) || '-' || YEAR(DATEADD('month',1,date))
END as reporting_month,
date,
ROW_NUMBER() OVER(PARTITION BY 
(CASE 
WHEN last_date IS NULL THEN MONTHNAME(date) || '-' || YEAR(date)
ELSE MONTHNAME(DATEADD('month',1,date)) || '-' || YEAR(DATEADD('month',1,date))
END) ORDER BY date
) as reporting_day,
new_customers as uk_new_customers
from uk_report as uk
left join UK_last_day as l on uk.date = l.last_date
where date < '2023-12-31'
)
,ROI_DATA AS (
SELECT 
reporting_month as roi_reporting_month,
reporting_day as roi_reporting_day,
new_customers as roi_new_customers,
DATE(reporting_date,'DD/MM/YYYY') as roi_reporting_date
FROM pd2023_wk12_roi_new_customers
)
,MATCHING_UK_DATES AS (
SELECT 
reporting_month,
reporting_day,
date as reporting_date,
uk_new_customers,
COALESCE(roi_new_customers,0) as roi_new_customers,
roi_reporting_month
FROM UK_REPORT_ADJ as UK
LEFT JOIN ROI_DATA as ROI on UK.date = ROI.roi_reporting_date
)
,ROI_DATA_ADJ AS (
SELECT 
roi_reporting_month,
roi_reporting_day,
roi_new_customers,
roi_reporting_date,
MIN(UK2.date) as next_uk_date
FROM ROI_DATA as ROI
LEFT JOIN UK_REPORT_ADJ as UK on UK.date = ROI.roi_reporting_date
LEFT JOIN UK_REPORT_ADJ as UK2 on UK2.date > ROI.roi_reporting_date
WHERE UK.date IS NULL
GROUP BY 
roi_reporting_month,
roi_reporting_day,
roi_new_customers,
roi_reporting_date
)
,COMBINED AS (
SELECT 
reporting_month,
reporting_day,
date as reporting_date,
0 as uk_new_customers,
roi_new_customers,
roi_reporting_month
FROM ROI_DATA_ADJ as ROI
INNER JOIN UK_REPORT_ADJ as UK on UK.date = ROI.next_uk_date

UNION ALL

SELECT *
FROM MATCHING_UK_DATES
)
SELECT 
CASE 
WHEN roi_reporting_month IS NULL THEN 'x'
WHEN LEFT(reporting_month,3) <> LEFT(roi_reporting_month,3) THEN 'x'
ELSE '' 
END as misalignment_flag,
reporting_month,
reporting_day,
reporting_date,
SUM(uk_new_customers) as uk_new_customers,
SUM(roi_new_customers) as roi_new_customers,
roi_reporting_month
FROM COMBINED
GROUP BY 
CASE 
WHEN roi_reporting_month IS NULL THEN 'x'
WHEN LEFT(reporting_month,3) <> LEFT(roi_reporting_month,3) THEN 'x'
ELSE '' 
END,
reporting_month,
reporting_day,
reporting_date,
roi_reporting_month;




